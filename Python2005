
# coding: utf-8

# In[16]:


# 
# PYTHON2005.PDF
# 
# Sintaxis Python
# Asignación =
a=3+2j     #es un numero complejo
b=7
print(a+b)
j=8
print(a+j)
a+(2+8j)
c=3+5j
print(a+c)
type(a)


# In[20]:


# Definicion de una funcion
def cuadrado(n):         #no olvidar los :
    return n*n

n=int(input("Ingrese un valor entero --->  "))
print(cuadrado(n))

# si no existe un RETURN la funcion devuelve NONE


# In[30]:


# Sentencia IF
n=int(input("Ingrese un valor entero --->  "))
if n%2 == 0:
    print("es un numero par")
elif n%2 == 0 and n%3 == 0:
    print("es un numero impar")
else:
    print("es un numero primo")
    
# El programa falla a partir del numero 25
# multiplos de 5 y 7
            


# In[ ]:


# Sentencia FOR
# range(i)    range(i,j)


# In[58]:


# Sentencia FILTER
# Devuelve los objetos de una lista que cumplen una funcion
# La funcion devuelve True si cumple y False si no
# En la vesrion 3.6 se trabaja como lista

def f(x): return x%2 != 0 and x%3 != 0

y=[2,3,4,5,6,7,8,9]
print(y)
print(f(5))
print(f(10))
print(list(filter(f,y)))
print(list(filter(f,range(2,35))))
# [5,7,11,13,17,19,23]


# In[61]:


# Funcion MAP
def cubo(x): return x*x*x

print(list(map(cubo, range(1,8))))


# In[74]:


# Funcion REDUCE
# solo si es vacio da error

import functools

def add(x,y): return x+y

print(functools.reduce(add, range(1,7)))
print(range(1,7))   # va de 1 a 6   (7 - 1)


# ------------------------------------ otro ejemplo
# inicializamos la lista 
lis = [ 1 , 4, 5, 7, 2, ] 
  
# uso reduce para calcular la suma de la lista 
print ("La suma de los elemntos de la lista es: ",end="") 
print (functools.reduce(lambda a,b : a+b,lis)) 
  
# uso reduce para calcular el mayor valor en la lista 
print ("El valor mas grande en la lista es: ",end="") 
print (functools.reduce(lambda a,b : a if a > b else b,lis)) 



# In[84]:


# Listas
vec= [2,4,6]
print([3 * x for x in vec])
print([3 * x for x in vec if x > 3])
print([[x,x**2] for x in vec])


# In[92]:


# CLASES

class MiClase:
    i = 12345   
    def f(self):
        return "Hola mundo cruel ...."

x = MiClase()
print(x.i)
print(x.f())

# SUBCLASES

class MiSubClase(MiClase):
...def f(self):
...return “HOLA MUNDO”
...
􀂄>>>x = MiSubClase()
􀂄>>>x.f()
“HOLA MUNDO”


# In[95]:


class Person:
  i = 12345
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hola mi nombre es " + self.name)

p1 = Person("Edison", 52)
p1.myfunc() 
p1.i


# In[21]:


s="martes 02 de julio del 2019"
s=s.replace(s[0],s[0].upper())
i = s.find("de")+3
s=s.replace(s[i],s[i].upper())
print(s)


# In[23]:


# Los módulos datetime y calendar amplían las posibilidades del módulo time 
# que provee funciones para manipular expresiones de tiempo.


import locale
locale.setlocale(locale.LC_TIME, 'es_ES.UTF-8')


from datetime import datetime, date, time, timedelta
# import calendar

                        #MI FUNCION DE FECHA
    
def MiFecha(s):
    s = s.strftime('%A, %d de %B del %Y')
    s=s.replace(s[0],s[0].upper())
    i = s.find("de")+3
    s=s.replace(s[i],s[i].upper())
    return s

ahora = datetime.now()  # Obtiene fecha y hora actual
print("Fecha y Hora:", ahora)  # Muestra fecha y hora
print("Fecha y Hora UTC:",ahora.utcnow())  # Muestra fecha/hora UTC
print("Día:",ahora.day)  # Muestra día
print("Mes:",ahora.month)  # Muestra mes
print("Año:",ahora.year)  # Muestra año
print("Hora:", ahora.hour)  # Muestra hora
print("Minutos:",ahora.minute)  # Muestra minuto
print("Segundos:", ahora.second)  # Muestra segundo
print("Microsegundos:",ahora.microsecond)  # Muestra microsegundo

now = datetime.now()
print(MiFecha(now))

